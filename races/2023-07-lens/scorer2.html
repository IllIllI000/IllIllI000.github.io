<html>
  <head>
    <meta name='robots' content='noindex'>
    <script>



function BotReportUtils(hasher, decoder) {
  this.hasher = hasher
  this.decoder = decoder

  this.extractFindingsJson = extractFindingsJson
  this.generateRubric = generateRubric
  this.makeRubricHash = makeRubricHash
}

async function generateRubric(salt, findings, aliases) {
  const aliasData = new Map()
  aliases.forEach(aliasGroup => {
    aliasGroup.forEach(alias => {
      aliasData.set(alias, aliasGroup)
    })
  })

  const hashes = []
  const classes = ['H','M','L','N','R','G','D']
  for (const finding of findings) {
    if (!finding.munged.ruleNum || !finding.munged.classDisplay) {
      continue
    }
    const numStr = `${finding.munged.ruleNum}`.padStart(2, '0')
    const label = `${finding.munged.classDisplay.toUpperCase()}â€‘${numStr}_dup`
    let titles = aliasData.get(finding.title)
    if (!titles) {
      titles = [finding.title]
    }
    for (const title of titles) {
      for (const clazz of classes) {
	// in the future we'll include individual instances, but for now
	// just operate on classes
	const hash = await this.makeRubricHash(clazz, salt, title, label)
	hashes.push(hash)
      }
    }
  }
  return {'salt': salt, 'hashes': hashes}
}

async function makeRubricHash(clss, salt, heading, label) {
  const entry = {'class': sanitizeStr(clss),
		 'salt': salt,
		 'title': sanitizeStr(heading),
		 'label': label
		}
  const eSorted = {};
  Object.keys(entry).sort().forEach((key) => {
    eSorted[key] = entry[key];
  });

  let hash = await this.hasher(JSON.stringify(eSorted))
  hash = hash.substr(0, 10)
  console.log(`${hash} - ${JSON.stringify(eSorted)}`)
  return hash
}

function extractFindingsJson(reportBody, botName) {
  const result = []
  const reportBodyBlocks = reportBody.split(/(?:^|\n)#+[ \u00A0]+(?=[^\n]*[0-9]+)/g)
  reportBodyBlocks.forEach(block => {
    let heading = this.decoder(block.split('\n')[0].replaceAll(/<\/?[^`>]+(>|$)/g, '').trim())
    if ('' === heading) {
      return
    }
    const firstSpaceIndex = heading.search(/[\s\u00A0]/g)
    const label = heading.substr(0, firstSpaceIndex).trim()
    if (!/[0-9]/.test(label)) {
      return
    }
    const title = heading.substr(firstSpaceIndex).trim()
    const munged = mungeLabelAndTitle(label, title)

    const instances = []
    const urlRegex = /(https?:\/\/[^\s\)]+)/gi
    let match
    while ((match = urlRegex.exec(block)) !== null) {
      const url = match[1]
      match = url.match(/\/([^/]+\.sol)(?:#L(\d+)(?:-L(\d+))?)?/i)
      if (null === match) {
        continue
      }
      const file = match[1]
      const lineFrom = match[2] ? parseInt(match[2]) : null
      const lineTo = match[3] ? parseInt(match[3]) : null
      const instance = {'url':url, 'file':file, 'lineFrom':lineFrom, 'lineTo':lineTo}
      instances.push(instance)
    }

    const findingsGroup = {'label':label, 'title':title, 'munged':munged, 'instances':instances, 'botName':botName}
    result.push(findingsGroup)
  })
  return result
}

function labelToRuleClass(label) {
  if (!label) {
    return null
  }
  return label.toUpperCase().replaceAll(/[^HMLNRGDI]/g, '').trim().charAt(0)
}

function labelToNumber(label) {
  if (!label) {
    return null
  }
  return label.replaceAll(/[^0-9]/g, '').replaceAll(/^0+/g, '').trim()
}

function labelToDisplayLabel(label) {
  if (!label) {
    return null
  }
  const ruleClass = labelToRuleClass(label)
  const number = labelToNumber(label)
  if (!ruleClass || !number || '' === ruleClass || '' === number) {
    return null
  }
  return ruleClass + '-' + number
}

function sanitizeStr(str) {
  if (!str) {
    return str
  }
  //return str.toLowerCase().replaceAll(/[\s\u00A0]+/g,' ').replaceAll(/[^a-z0-9\.\_\/: \-\)\(\[\]#]/g, '').trim()
  return str.toLowerCase().replaceAll(/[\s\u00A0]+/g,' ').replaceAll(/`/g, '').replaceAll(/[^a-z0-9 ]/g, ' ').replaceAll(/\s+/g, ' ').trim()
}

function mungeLabelAndTitle(label, title) {
  const number = labelToNumber(label)
  const ruleClass = labelToRuleClass(label)
  const ruleClassSanitized = sanitizeStr(ruleClass)
  const displayLabel = labelToDisplayLabel(label)
  const titleSanitized = sanitizeStr(title)
  const result = {'ruleNum':number ? parseInt(number) : null, 'classDisplay':ruleClass, 'classSanitized':ruleClassSanitized, 
                  'labelDisplay':displayLabel, 'titleSanitized':titleSanitized}
  return result
}

function mungeLabelTitleAndScore(label, title, score) {
  const result = mungeLabelAndTitle(label, title, score)
  const scoreDisplay = score ? score : ''
  const scoreRuleClass = labelToRuleClass(score)
  let scoreCleaned = scoreDisplay !== '' ? scoreRuleClass : '_'
  if ('' == scoreCleaned) {
    scoreCleaned = '?'
  }
  if (/^(-[0-9]+|X|FALSE)$/.test(scoreDisplay.toUpperCase())) {
    scoreCleaned = 'D'
  }
  result.scoreDisplay = scoreDisplay
  result.scoreCleaned = scoreCleaned
  return result
}


// Export functions based on the environment
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  // This code will run in Node.js

  const cheerio = require('cheerio')
  function decodeHtmlEntities(encodedString) {
    const node = cheerio.load(encodedString, 
			      { xml: true, decodeEntities: false }, false);
    return node.html({ decodeEntities: false })
  }
  
  const crypto = require('crypto');
  async function hashStr(str) {
    return crypto.createHash('sha256').update(str).digest('hex')
  }

  function getBotReportUtils() {
    return new BotReportUtils(hashStr, decodeHtmlEntities)
  }

  module.exports.getBotReportUtils = getBotReportUtils
} else {
  // This code will run in the browser

  function decodeHtmlEntities(encodedString) {
    const tempElement = document.createElement('textarea')
    tempElement.innerHTML = encodedString
    return tempElement.value
  }

  async function hashStr(str) {
    const encoder = new TextEncoder()
    const dataBuffer = encoder.encode(str)
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer)
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('')
    const partialHash = hashHex.substr(0, 10)
    return partialHash
  }

  function getBotReportUtils() {
    return new BotReportUtils(hashStr, decodeHtmlEntities)
  }
}

/**
const bru = getBotReportUtils()
const body = require('fs').readFileSync("/tmp/report.md", 'utf8')
const findings = bru.extractFindingsJson(body, 'MyBotName')
bru.generateRubric("salt123", findings, []).then(r => {
  console.log(JSON.stringify(r))
})
/**/



var reportCount = 0
var salt
var hashes
var urlCount = 0
var allScoredData
var botTitleSanitizedToFindingsGroup
var keyToScoresheetFormat
var bru = getBotReportUtils()

function makeAbbrElement(abbr, title) {
  if ('' == abbr) {
    //abbr = '\u00A0\u00A0\u00A0' // &nbsp;
  }
  const abbrElement = document.createElement('abbr')
  abbrElement.textContent = abbr
  abbrElement.title = title
  abbrElement.style.textDecoration = 'none'
  return abbrElement
}

function addReportFormFields(label, body, scoresheet) {
  const reportsElement = document.getElementById('reports')
  const key = `report${reportCount++}`
  if (!label || '' == label) {
    label = `Bot ${reportCount}`
  }
  if (!body) {
    body = ''
  }
  if (!scoresheet) {
    scoresheet = ''
  }

  // results
  const tableElement = document.createElement('table')
  const theadElement = tableElement.createTHead()
  const rowElement = theadElement.insertRow()
  const headings = ['label', 'title', 'scores', 'rubric', 'differences', 'comments']
  for (const heading of headings) {
    const headingElement = document.createElement('th')
    headingElement.textContent = heading
    rowElement.appendChild(headingElement)
  }
  const tbodyElement = tableElement.createTBody()
  tbodyElement.id = `${key}_tbody`
  const resultsHeadingElement = document.createElement('h3')
  resultsHeadingElement.textContent = `${label}:`
  const resultsDivElement = document.createElement('div')
  resultsDivElement.id = `${key}_results`
  resultsDivElement.appendChild(resultsHeadingElement)
  resultsDivElement.appendChild(tableElement)
  const allResultsDivElement = document.getElementById('results')
  allResultsDivElement.appendChild(resultsDivElement)

  // input
  const containerElement = document.createElement('div')
  containerElement.id = key

  const botLabelInputElement = document.createElement('input')
  botLabelInputElement.type = 'text'
  botLabelInputElement.size = 20
  botLabelInputElement.value = label
  botLabelInputElement.id = `${key}_name`
  botLabelInputElement.addEventListener('input', function() {
    const label = botLabelInputElement.value
    resultsHeadingElement.textContent = `${label}:`
  })
  const botLabelLabelElement = document.createElement('label')
  botLabelLabelElement.textContent = 'Bot name: '
  botLabelLabelElement.htmlFor = botLabelInputElement.id
  const botReportTextareaElement = document.createElement('textarea')
  botReportTextareaElement.value = body
  botReportTextareaElement.rows = 20
  botReportTextareaElement.cols = 60
  botReportTextareaElement.id = `${key}_body`
  const botReportLabelElement = document.createElement('label')
  botReportLabelElement.textContent = 'Report body markdown (without TOC) of the report:'
  botReportLabelElement.htmlFor = botReportTextareaElement.id

  const botScoresheetTextareaElement = document.createElement('textarea')
  botScoresheetTextareaElement.value = scoresheet
  botScoresheetTextareaElement.rows = 20
  botScoresheetTextareaElement.cols = 120
  botScoresheetTextareaElement.id = `${key}_scoresheet`
  const botScoresheetLabelElement = document.createElement('label')
  botScoresheetLabelElement.textContent = 'Optional tab-separated judging scores for report (<label>\t<title>\t<score>) (you can copy and paste the three cols from a spreadsheet):'
  botScoresheetLabelElement.htmlFor = botScoresheetTextareaElement.id

  const removeAElement = document.createElement('a')
  removeAElement.href = '#'
  removeAElement.textContent = '[delete]'
  removeAElement.onclick = function() { 
    event.preventDefault()
    reportsElement.removeChild(containerElement)
    allResultsDivElement.removeChild(resultsDivElement)
  }
  removeAElement.style.textDecoration = 'none'
  removeAElement.style.paddingLeft = '1em'

  containerElement.appendChild(botLabelLabelElement)
  containerElement.appendChild(botLabelInputElement)
  containerElement.appendChild(removeAElement)
  containerElement.appendChild(document.createElement('br'))

  const reportContainerElement = document.createElement('div')
  reportContainerElement.appendChild(botReportLabelElement)

  reportContainerElement.appendChild(document.createElement('br'))
  reportContainerElement.appendChild(botReportTextareaElement)
  reportContainerElement.style.cssFloat = 'left'
  containerElement.appendChild(reportContainerElement)
  const scoresheetContainerElement = document.createElement('div')
  scoresheetContainerElement.appendChild(botScoresheetLabelElement)
  scoresheetContainerElement.appendChild(document.createElement('br'))
  scoresheetContainerElement.appendChild(botScoresheetTextareaElement)
  containerElement.appendChild(scoresheetContainerElement)

  containerElement.appendChild(document.createElement('br'))
  containerElement.appendChild(document.createElement('br'))
  reportsElement.append(containerElement)


}


function sanitizeStr(str) {
  if (!str) {
    return str
  }
  //return str.toLowerCase().replaceAll(/[\s\u00A0]+/g,' ').replaceAll(/[^a-z0-9\.\_\/: \-\)\(\[\]#]/g, '').trim()
  return str.toLowerCase().replaceAll(/[\s\u00A0]+/g,' ').replaceAll(/`/g, '').replaceAll(/[^a-z0-9 ]/g, ' ').replaceAll(/\s+/g, ' ').trim()
}

function htmlEncode(text) {
  var div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

const setReplacer = (key, value) => {
  if (value instanceof Set) {
    return [...value] // Convert set to array
  }
  return value
}

var isScoring = false
async function score() {
  if (isScoring) {
    return
  }
  isScoring = true
  
  const debugElement = document.getElementById('debug')
  debugElement.innerHTML = ''

  const rubricStr = document.getElementById('rubric').value.trim()
  const rubric = rubricStr != "" ? JSON.parse(rubricStr) : {}
  hashes = new Set(rubric.hashes)
  salt = rubric.salt
  //console.log(hashes)

  allScoredData = new Map()
  botTitleSanitizedToFindingsGroup = new Map()
  keyToScoresheetFormat = new Map()
  const reportsElement = document.getElementById('reports')
  const childIds = Array.from(reportsElement.children).map((childElement) => childElement.id)
  const promises = childIds.map(scoreReport)
  await Promise.all(promises)

  for (const [scoredFindingId, scoreToScoreIds] of allScoredData) {
    if (1 >= scoreToScoreIds.size) {
      continue
    }
    for (const [score, scoreIds] of scoreToScoreIds) {
      for (const scoreId of scoreIds) {
        const elemId = scoreId.split(':').slice(0,3).join(':')
        const classSanitized = scoreId.split(':')[1]
        const elem = document.getElementById(elemId)
        if (!elem) console.log(elemId, elem)
        const others = new Map(scoreToScoreIds)
        others.delete(score)
        const scores = new Set(scoreToScoreIds.keys())
        scores.add(score)
        scores.delete('D')
        if (1 < scores.size) {
          elem.style.border = 'solid red 3px'
        } else if ('d' != classSanitized) {
          //elem.style.border = 'solid orange 3px'
        } else {
          continue
        }
        elem.textContent = score + ' vs ' + JSON.stringify(Object.fromEntries(others), setReplacer)
      }
    }
  }

  debugElement.appendChild(document.createElement('br'))
  debugElement.appendChild(document.createTextNode('Done'))
  debugElement.appendChild(document.createElement('br'))
  isScoring = false
}

function labelToRuleClass(label) {
  if (!label) {
    return null
  }
  return label.toUpperCase().replaceAll(/[^HMLNRGDI]/g, '').trim().charAt(0)
}

function labelToNumber(label) {
  if (!label) {
    return null
  }
  return label.replaceAll(/[^0-9]/g, '').replaceAll(/^0+/g, '').trim()
}

function labelToDisplayLabel(label) {
  if (!label) {
    return null
  }
  const ruleClass = labelToRuleClass(label)
  const number = labelToNumber(label)
  if (!ruleClass || !number || '' === ruleClass || '' === number) {
    return null
  }
  return ruleClass + '-' + number
}

function mungeLabelAndTitle(label, title) {
  const number = labelToNumber(label)
  const ruleClass = labelToRuleClass(label)
  const ruleClassSanitized = sanitizeStr(ruleClass)
  const displayLabel = labelToDisplayLabel(label)
  const titleSanitized = sanitizeStr(title)
  const result = {'ruleNum':number, 'classDisplay':ruleClass, 'classSanitized':ruleClassSanitized, 
                  'labelDisplay':displayLabel, 'titleSanitized':titleSanitized}
  return result
}

function mungeLabelTitleAndScore(label, title, score) {
  const result = mungeLabelAndTitle(label, title, score)
  const scoreDisplay = score ? score : ''
  const scoreRuleClass = labelToRuleClass(score)
  let scoreCleaned = scoreDisplay !== '' ? scoreRuleClass : '_'
  if ('' == scoreCleaned) {
    scoreCleaned = '?'
  }
  if (/^(-[0-9]+|X|FALSE)$/.test(scoreDisplay.toUpperCase())) {
    scoreCleaned = 'D'
  }
  result.scoreDisplay = scoreDisplay
  result.scoreCleaned = scoreCleaned
  return result
}

function extractFindingsJson(reportBody, botName) {
  const result = []
  const reportBodyBlocks = reportBody.split(/(?:^|\n)#+[ \u00A0]+(?=[^\n]*[0-9]+)/g)
  for (const block of reportBodyBlocks) {
    let heading = bru.decoder(block.split('\n')[0].replaceAll(/<\/?[^`>]+(>|$)/g, '').trim())
    if ('' === heading) {
      continue
    }
    const firstSpaceIndex = heading.search(/[\s\u00A0]/g)
    const label = heading.substr(0, firstSpaceIndex).trim()
    const title = heading.substr(firstSpaceIndex).trim()
    const munged = mungeLabelAndTitle(label, title)

    const instances = []
    const urlRegex = /(https?:\/\/[^\s\)]+)/gi
    let match
    while ((match = urlRegex.exec(block)) !== null) {
      const url = match[1]
      match = url.match(/\/([^/]+\.sol)(?:#L(\d+)(?:-L(\d+))?)?/i)
      if (null === match) {
        continue
      }
      const file = match[1]
      const lineFrom = match[2]
      const lineTo = match[3]
      const instance = {'url':url, 'file':file, 'lineFrom':lineFrom, 'lineTo':lineTo, 'urlNum':urlCount++}
      instances.push(instance)
    }

    const findingsGroup = {'label':label, 'title':title, 'munged':munged, 'instances':instances, 'botName':botName}
    result.push(findingsGroup)
  }
  return result
}

function extractScoresheetJson(scoresheet, botName, stillMissing) {
  const stillMissingCols = []
  const stillMissingKb = []
  const colBased = extractScoresheetJsonCols(scoresheet, botName, stillMissingCols)
  const kbBased = extractScoresheetJsonKb(scoresheet, botName, stillMissingKb)
  const isColBased = colBased.length >= kbBased.length
  //console.log(botName, 'col or kb?', isColBased)
  return [isColBased ? colBased : kbBased, isColBased, isColBased ? stillMissingCols : stillMissingKb]
}

function extractScoresheetJsonCols(scoresheet, botName, stillMissing) {
  const result = []
  for (const line of scoresheet.split('\n')) {
    const lineTrimmed = line.trim()
    if ('' === lineTrimmed) {
      continue
    }
    const parts = lineTrimmed.split('\t')
    for (let i = 0; i < parts.length; ++i) {
      parts[i] = parts[i].trim()
    }

    const label = parts[0]
    const title = parts[1]
    if (!label || !title) {
      stillMissing.push(lineTrimmed)
      continue
    }
    const score = parts[2]
    const remaining = parts.slice(3)
    const munged = mungeLabelTitleAndScore(label, title, score)
    const scoring = {'label':label, 'title':title, 'score':score, 'remaining':remaining, 'munged':munged, 'botName':botName}
    const fg = botTitleSanitizedToFindingsGroup.get(botName + '-'+ scoring.munged.titleSanitized)
    if (!fg) {
      stillMissing.push(lineTrimmed)
      continue
    }
    result.push(scoring)
  }

  return result
}

// format of https://github.com/GalloDaSballo/string-regex/blob/c2cedec33e0af791e159a1254a9f34242466f80b/src/lib.ts#L91-L95
function extractScoresheetJsonKb(scoresheet, botName, stillMissing) {
  const result = []
  const lines = scoresheet.split('\n')
  for (let i = 1; i < lines.length; i += 2) {
    const scoreStr = lines[i].trim()
    const headingStr = lines[i - 1].trim()
    if ('' === scoreStr || '' === headingStr) {
      continue
    }

    const parts = scoreStr.split(/[\s\u00A0]+/)
    const score = parts[0]
    const remaining = parts.slice(1).join(' ').trim()

    const firstSpaceIndex = headingStr.search(/[\s\u00A0]/g)
    // can be (g-04-use-at-least-solidity-version-0819-to-gain-some-gas-boost) -> G-40819, and not useful, so don't use it
    let label = '' // headingStr.substr(0, firstSpaceIndex).trim()
    let title = headingStr.trim()//labelToDisplayLabel(label) ? headingStr.substr(firstSpaceIndex).trim() : headingStr.trim()
    title = title.replace(/^\([^)]+?\)\s*/, '').replace(/[\s]+[0-9,]+[\s]*$/, '') // link parens and trailing gas
    if (/*!label || */!title) {
      stillMissing.push(headingStr)
      continue
    }
    const munged = mungeLabelTitleAndScore(label, title, score)
    const scoring = {'label':label, 'title':title, 'score':score, 'remaining':remaining, 'munged':munged, 'botName':botName}
    const fg = botTitleSanitizedToFindingsGroup.get(botName + '-'+ scoring.munged.titleSanitized)
    if (!fg) {
      // better to fail than to use a score that won't be used for actual scoring
      stillMissing.push(headingStr)
      continue
    }
    if (!scoring.munged.labelDisplay) {
      scoring.label = fg.label
      scoring.munged = mungeLabelTitleAndScore(fg.label, title, score)
    } 
    if (!scoring.munged.labelDisplay) {
      stillMissing.push(headingStr)
      continue
    }

    result.push(scoring)
  }

  return result
}

function addToScoresheet(key, findingsGroup, score) {
  const scoresheetTextareaElement = document.getElementById(`${key}_scoresheet`)
  let value
  if (keyToScoresheetFormat.get(key)) {
    value = scoresheetTextareaElement.value.trim() + 
      `\n${bru.decoder(findingsGroup.label)}\t${bru.decoder(findingsGroup.title)}\t${score}`
  } else {
    value = scoresheetTextareaElement.value.trim() + 
      `\n${bru.decoder(findingsGroup.title)}\n${score}`
  }
  scoresheetTextareaElement.value = value.trim()
}

async function scoreReport(key) {
  //console.log(key)

  const labels = []//'disputed', 'sevInflated', 'outOfScope', 'gasNotQa', 'qaNotGas']
  for (let i = 1; i < 100; ++i) {
    const numStr = `${i}`.padStart(2, '0')
    labels.push(`Hâ€‘${numStr}_dup`)
    labels.push(`Mâ€‘${numStr}_dup`)
    labels.push(`Lâ€‘${numStr}_dup`)
    //labels.push(`Râ€‘${numStr}_dup`)
    labels.push(`Nâ€‘${numStr}_dup`)
    labels.push(`Gâ€‘${numStr}_dup`)
    labels.push(`Dâ€‘${numStr}_dup`)
  }
  //console.log(labels)

  const botName = document.getElementById(`${key}_name`).value
  const tbodyElement = document.getElementById(`${key}_tbody`)
  // tbodyElement.style.display = 'none'
  tbodyElement.innerHTML = ''
  const reportBody = document.getElementById(`${key}_body`).value
  const findingsJson = bru.extractFindingsJson(reportBody, botName)
  findingsJson.forEach(findingsGroup => {    
    const key = findingsGroup.botName + '-' + findingsGroup.munged.titleSanitized
    if ('d' == findingsGroup.munged.classSanitized && !botTitleSanitizedToFindingsGroup.get(key)) {
      return // for now won't add to map, because gets applied to end of the list which are disputed
    }
    botTitleSanitizedToFindingsGroup.set(key, findingsGroup)
  })
  //console.log(JSON.stringify(findingsJson, null, 2))
  const displayLabelToScore = new Map()
  const scoresheet = document.getElementById(`${key}_scoresheet`).value
  const scoresheetData = extractScoresheetJson(scoresheet, botName)
  //console.log(scoresheetData)
  const scoresheetJson = scoresheetData[0]
  keyToScoresheetFormat.set(key, scoresheetData[1])
  const stillMissing = scoresheetData[2]
  if (0 != stillMissing.length) {
    //console.log(stillMissing)
    alert(`Titles matching the following score titles weren't found in the report:\n - ${stillMissing.join('\n - ')}`)
  }

  //console.log(JSON.stringify(scoresheetJson, null, 2))
  for (const scoring of scoresheetJson) {
    displayLabelToScore.set(scoring.munged.labelDisplay, scoring)
  }
  for (const findingsGroup of findingsJson) {
    let scoring = displayLabelToScore.get(findingsGroup.munged.labelDisplay)
    const hasScore = undefined != scoring
    if (!scoring) {
      scoring = {'munged':{'scoreDisplay':'','scoreCleaned': '_'}, 'botName':botName, 'label':findingsGroup.label}
    }
    const scoreReported = findingsGroup.munged.classDisplay
    const isPassthroughScore = ('_' == scoring.munged.scoreCleaned)
    const scoreCleaned = isPassthroughScore ? scoreReported : scoring.munged.scoreCleaned
    const scoreId = scoring.botName + ':' + findingsGroup.munged.classSanitized + ':' + scoring.label //+ ':' + scoreCleaned + (entry.url ? (':' + entry.url) : '')

    const entry = sortObj({'class': findingsGroup.munged.classSanitized, 'salt':salt, 
                           'title': findingsGroup.munged.titleSanitized, 'label': '<placeholder>'})
    //console.log(entry)
    let variantsWithAlteredLabels = labels.map(label => {
      const v = cloneObj(entry)
      v.label = label
      return v
    })

    await getHashToData(variantsWithAlteredLabels).then(hashToFindingVariant => {
      const hits = []
      const classes = new Set()
      const labelsHit = new Set()
      for (const [hash, variant] of hashToFindingVariant) {
        if (!hashes.has(hash)) {
          //console.log(hash)
          continue
        }
        //console.log(hash,variant)
        const rubricScore = variant.label.charAt(0)
        classes.add(rubricScore)
        labelsHit.add(variant.label)
        if (!isPassthroughScore || scoreCleaned === rubricScore) {
          const abbrElement = makeAbbrElement(rubricScore, variant.label)
          hits.push(abbrElement)
        } else {
          const aElement = document.createElement('a')
          aElement.href = '#'
          aElement.textContent = rubricScore
          aElement.title = `Issue does not have an entry in the scoresheet and is using the stated severity (${scoreCleaned}). Click to add the rubric's (${variant.label}) severity (${rubricScore}) to the scoresheet (you must rescore after you've finished all scoresheet updates)`
          aElement.onclick = function() {
            event.preventDefault()
            addToScoresheet(key, findingsGroup, rubricScore)
            const parentNode = aElement.parentNode
            const innerText = parentNode.innerText
            parentNode.innerHTML = ''
            parentNode.textContent = innerText
          }
          hits.push(aElement)
        }
      }

      const scoredFindingId = (0 != labelsHit.size) ? JSON.stringify(Array.from(labelsHit)) : findingsGroup.munged.titleSanitized
      let scoreToScoredIds = allScoredData.get(scoredFindingId)
      if (!scoreToScoredIds) {
        scoreToScoredIds = new Map()
        allScoredData.set(scoredFindingId, scoreToScoredIds)
      }
      let scoreIds = scoreToScoredIds.get(scoreCleaned)
      if (!scoreIds) {
        scoreIds = new Set()
        scoreToScoredIds.set(scoreCleaned, scoreIds)
      }
      scoreIds.add(scoreId)

      const classesArr = Array.from(classes)
      const trElement = document.createElement('tr')
      let tdElement
      tdElement = document.createElement('td')
      tdElement.textContent = findingsGroup.label
      trElement.appendChild(tdElement)

      tdElement = document.createElement('td')
      tdElement.style.borderBottom = '1px solid lightgray'
      tdElement.textContent = findingsGroup.title
      trElement.appendChild(tdElement)



      tdElement = document.createElement('td')
      if (isPassthroughScore) {
        const aElement = document.createElement('a')
        aElement.href = '#'
        aElement.textContent = scoreCleaned
        if (hasScore) {
          aElement.title = `Using stated severity since scoresheet had a blank value for the score. Click to explicitly add this issue's stated severity (${scoreCleaned}) to the scoresheet`
        } else {
          aElement.title = `Issue does not have an entry in the scoresheet and is using the stated severity (${scoreCleaned}). Click to add this issue's stated severity (${scoreCleaned}) to the scoresheet (you must re-score after you've finished all scoresheet updates)`
        }
        const thisTd = tdElement
        aElement.onclick = function() {
          event.preventDefault()
          thisTd.removeChild(aElement)
          //thisTd.textContent = scoreCleaned
          thisTd.appendChild(makeAbbrElement(scoreReported, scoreCleaned))
          thisTd.style.fontWeight = 'bold'
          addToScoresheet(key, findingsGroup, scoreCleaned)
        }
        tdElement.appendChild(aElement)
      } else {
        const abbrElement = makeAbbrElement(scoring.munged.scoreDisplay, /*scoring.botName + ':' + */scoreCleaned)
        tdElement.appendChild(abbrElement)
        tdElement.style.fontWeight = 'bold'
      }
      trElement.appendChild(tdElement)
      if ('I' == scoreCleaned || 'D' == scoreCleaned) {
        // ignore
      } else if ('?' == scoreCleaned) {
        tdElement.style.background = 'red'
      } else if (classesArr.length > 1) {
        tdElement.style.background = 'yellow'
      } else if (classesArr.length == 1 && '?' !== classesArr[0]) {
        const rubricScore = classesArr[0]
        if ('G' == rubricScore && ('N' == score || 'L' == scoreCleaned)) {
          if ('G' != scoreReported) {
            // reported Gas as something else
            tdElement.style.background = 'red'
          }
          // allow 'L' or 'N' for 'G'
        } else if ('R' == scoreCleaned && ('N' == rubricScore || 'L' == rubricScore) && ('L' == scoreReported || 'N' == scoreReported)) {
          // allow 'R' for 'N' or 'L'
        } else if (scoreCleaned !== rubricScore) {
          tdElement.style.background = 'orange'
        }
      } else if (0 === hits.length && '_' == scoring.munged.scoreCleaned && !hasScore) {
        tdElement.style.border = 'solid yellow 3px'
      }

      tdElement = document.createElement('td')
      const isHasRubric = (0 != hits.length)
      if (!isHasRubric) {
        tdElement.textContent = '?'
      } else {
        tdElement.appendChild(hits[0])
        for (const elem of hits.slice(1)) {
          tdElement.appendChild(document.createTextNode(', '))
          tdElement.appendChild(elem)
        }
      }
      trElement.appendChild(tdElement)

      tdElement = document.createElement('td')
      tdElement.id = scoring.botName + ':' + findingsGroup.munged.classSanitized + ':' + scoring.label
      trElement.appendChild(tdElement)

      tdElement = document.createElement('td')
      tdElement.textContent = scoring.remaining ? scoring.remaining.join(' ') : ''
      trElement.appendChild(tdElement)


      tbodyElement.appendChild(trElement)
    })
  }
  tbodyElement.style.display = 'table-row-group'  
}

function sortObj(obj) {
  const result = {}
  Object.keys(obj).sort().forEach((key) => {
    result[key] = obj[key]
  })
  return result
}
function cloneObj(obj) {
  return JSON.parse(JSON.stringify(obj))
}


async function getHashToData(data) {
  const hashPromises = data.map(async datum => {
    const str = JSON.stringify(datum)
    const h = await bru.hasher(str)
    return [h, datum]
  })

  const hashEntries = await Promise.all(hashPromises)
  return new Map(hashEntries)
}

    </script>
    <style>
      td { white-space: nowrap; }
    </style>
  </head>
  <body>
    <h1>Bot Race Scorer</h1>

    <p>The purpose of this tool is to identify cases where two bots have identified the same issue, but have used different headings to 
    describe them, and or given them different severities. If two bots have found the same issue, they should be given the same
    number of points during judging, regardless of their respective stated severities (though if one has excessivly inflated 
    the severity, a penalty should probably be assessed).</p>

    <p>This tool takes as input, the report being scored (markdown) and another bot's 'rubric' (JSON), and identifies known
    aliases for the headings in report being scored, based on obfuscated data in the rubric. Try clicking the 'score' button
    below the textareas, which have been populated with data from a previous race, to see how scoring works. This tool solely operates
    on the data provided in the textareas below and does not perform any network-related operations. You can inspect the source by
    right clicking and viewing the source, or you can view it <a href='https://github.com/IllIllI000/IllIllI000.github.io/tree/main/races'>here</a>. 
    The tool is based on ideas from <a href='https://blog.cloudflare.com/validating-leaked-passwords-with-k-anonymity/'>this</a> article.</p>

    <p>A major difficulty in scoring bot races is that the top bots all have slightly different wording for their issues, so blind 
    matching of titles will not work. This tool pushes the task of matching bot titles to the owner of each submission rubric,
    where each rubric-generating bot owner has their own database of mappings of titles, and their rubric is generated based on their
    mappings, rather than forcing each bot owner to use the same title. This is a lot more work for each rubric submitter, but
    it leaks a lot less rule information to non-participants, and is thus more fair to the people who put in the work to gather
    and keep the data up to date. This means that while the tool is open-source, the data from which the rubrics are generated
    is private to each bot owner.</p>

    <p>In cases where the rubric doesn't have an entry for a finding, or when a rubric is not provided, the tool uses approximate title
    matching in order to identify duplicates, where possible.</p>

    <form id='scoreForm' onsubmit='event.preventDefault(); score();'>
      <label for='textarea'>Optional rubric from the bottom of the IllIllI-bot report:</label><br/>
      <textarea id='rubric' rows='5' cols='60'>


      </textarea>
      <br/><br/>

      <div id='reports'></div>

      <a href='#' onclick='event.preventDefault(); addReportFormFields();'>[add]</a> another report<br/><br/>

      <input type='submit' value='score'>
    </form>
    
    <br/>

    <p><b>How to read this table</b>: The report you've pasted above will be parsed into individual headings, with one row per issue type. 
    The '<i>rubric</i>' column is not meant to match the '<i>label</i>' column, but is instead meant to match the specific finding from the 
    IllIllI-bot report's headings (seen <a href='https://illilli000.github.io/races/2023-07-lens/key.txt'>here</a> for the default page data). 
    When there is more than one value in the '<i>rubric</i>' column, that means there are some instances that appear in multiple categories. 
    For example, label '<i>[L-05]</i>' has rubric entries (if you hover your mouse over '<i>L</i>' and '<i>D</i>') '<i>Lâ€‘02_dup, Dâ€‘02_dup</i>', 
    which means '<i>[L-05] Array lengths not checked</i>' in the pasted report 
    has some entries that may match either '<i>[Lâ€‘02] Array lengths not checked</i>' (valid instances) or '<i>[Dâ€‘02] Array lengths not checked</i>' 
    (disputed/invalid instances) from the IllIllI-bot report. A match of '<i>?</i>' means that there isn't currently an alias that matches
    the report's heading in the rubric; there may or may not be a duplicate in the IllIllI-bot report, or it could be an invalid finding in the 
    other bot's report. The judge will have to investigate as would normally be done.</p>

    <p>The scoresheet textarea (the tab-separated one) is where the judge would paste their scores from excel, to have the tool fill in
    the '<i>scores</i>' column. If an entry does not have any row in the scoresheet, it's assumed to be scored as the submission's reported
    severity. If the given issue is one of multiple values identified by the rubric, it will be colored yellow as a reminder to ensure that
    the correct score was chosen. If there is no scoresheet score (defaults to the reported severity) and no rubric score, the cell will be 
    bordered with yellow. If there is only one rubric match and the score doesn't match the rubric, it will be colored orange as an
    indication that the issue should be investigated. If the score is unrecognized, it will be colored red. Hover your mouse over any 
    cell of the '<i>scores</i>' column to see what score the tool interpreted the string as. Note that '<i>D</i>', '<i>X</i>', and 
    negative numbers are all mean disputed entries (penalties), and 'I' is for ignored entries.</p>

    <p>The '<i>differences</i>' column uses the entry's score (either the scoresheet severity, or the submitted severity if one wasn't given),
    and compares that severity to all other bots' severities for that entry, where the rubric identified the issues as being the same. For
    example, the first cell highlighted in red in that column is '<i>L vs {"N":["IllIllI-bot:n:[Nâ€‘48]"]}</i>', which means that the severity
    of the current row is '<i>L</i>', but IllIllI-bot has the same issue for entry '<i>[Nâ€‘48]</i>', but there it was given a severity of 
    '<i>N</i>' instead. Since the rubric properly identified them as the same issue, they should be given the same score. This can be 
    accomplished by adding the following line to the end of 0x6980-bot's scoresheet, and re-running the scoring: 
    <i>[L-10]<span style="white-space: pre;tab-size:4">&#9;</span>Int casting `block.timestamp` can reduce the lifespan of a
    contract<span style="white-space: pre;tab-size:4">&#9;<span>N</i>.

    <p>The purpose of this tool is to ensure that two reports with the same issue get the same score for that issue. For example, the winning 
    bot had '<i>[L-10] Int casting `block.timestamp` can reduce the lifespan of a contract</i>' as 'Low' severity, but looking at the 
    '<i>rubric</i>' column (<i>Nâ€‘57_dup</i>), IllIllI-bot had the same finding as '<i>[Nâ€‘57] Contract timekeeping will break earlier than the 
    Ethereum network itself will stop working</i>' with 'Non-critical' severity. A judge judging these two reports should give both 
    '<i>[L-10]</i>' in this report, and '<i>[Nâ€‘57]</i>' in IllIllI-bot's report, the same number of points.</p>

    <p><b>When to use this tool for judging</b>: The easiest way to use this tool is as a final check before submitting bot scores. Paste the 
    winning bot's markdown and IllIllI-bot's rubric (and your scoring columns from your spreadsheed if you have one) and click the 'score' 
    button, then check each of the non-white cells. If there are none, you're done - great! If there are some, drill down into the individual 
    findings and see why the scores don't match, and make sure that the issues in both reports got the same scores for those specific issues.
    Make sure that if you don't have enough time to look at everything, that you at least address the entries in red, which will show cases
    where you've given bots different severities for the same finding.</p>

    <div id='results'></div>

    <div id='debug'></div>
    
    <script>

    </script>
  </body>
</html>
